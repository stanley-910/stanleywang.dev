---
title: 'Beta Technologies Case Study'
date: '2025-07-07'
readingTime: '15 min'
tags: ['Software', 'Aerospace', 'Finite Element Analysis']
---

<TOC title="Beta Technologies Case Study" />

<Img
  src="/images/experience/beta-case-study/alia-dark.JPG"
  lightSrc="/images/experience/beta-case-study/alia-light.JPG"
  alt="Alia"
  caption="Sketch of the Alia CX300 by me"
/>

Meet the Alia CX300. She's an electric, fixed-wing, conventional take-off & landing plane, rated for 336 nautical miles at 153 knots, in under an hour of charge!

BETA Technologies, the company that I interned for this past Winter, is currently working on getting her FAA certified.

In very broad strokes, to demonstrate the airworthiness of an experimental aircraft, you need to show that it can withstand a multitude of extreme loads under a variety of environmental conditions and operational scenarios.

Before designs can be built on the manufacturing floor, specific load levels first need to be met.

- A Limit Load is the maximum load expected during normal service; the plane cannot experience permanent deformation under these loads.
- An Ultimate Load is typically 1.5x the limit load. The plane's structure is allowed to permanently deform under the ultimate load, but it must be able to withstand it for at least 3 seconds without failing catastrophically.

So, let's say you're tasked with analyzing the Alia's wing structure and testing it against those load thresholds. The model you are working with consists of all the elements, nodes, and materials of the entire aircraft. This is because you need to find out how the wing structure reacts under loads in conjunction with the fuselage, not just when it's floating by itself.

Running that analysis, however, can be a huge time-investment, depending on how complex the other parts of your model are. For example, if the nose is modeled as a million little finite elements, it's going to take a lot longer to get a read on your wing than plausible.

Not all hope is lost, though! By pre-calculating the stiffness matrices and load vectors at the boundary nodes where the wing meets the rest of the aircraft, you can create what's called a 'superelement' for the fuselage. This superelement captures all the structural behavior of the fuselage but condenses it down to just the boundary interface points.

Separating the wing from the plane sounds straightforward in theory.

In practice, it's far more complex. NASTRAN, the industry-standard structural analysis software, represents aircraft models through millions of intricate **cards**. These cards define every aspect of the model—elements, coordinates, materials, and constraints. Each individual card is a block of structured text with a variety of fields. Some of which include the card type, the ID number, the grid points it occupies, and the coordinate system it exists on.

Together, these cards create a **run-deck** representing the finite element makeup of an aircraft, and structural analysis programs like NASTRAN use it to calculate stress distributions, deformations, and failure modes.

So to separate the wing from the Alia, you'd need to:

1. Identify all elements belonging to the **Residual Structure** (wing)
2. Identify all elements belonging to the **Reduced Structure** (rest of plane)
3. Find the **boundary nodes**—the subset of nodes that belong to both residual and reduced elements (where the wing connects to the fuselage)
4. Create two separate models from the original: one with the reduced structure elements commented out (wing-only model), and another with the residual structure elements commented out (superelement model), while preserving the boundary nodes in both

<Img
  src="/images/experience/beta-case-study/alia-dark-red.JPG"
  lightSrc="/images/experience/beta-case-study/alia-light-red.JPG"
  alt="Alia"
  caption="Residual wing structure (red) separated at the interface nodes"
/>

This process—identifying millions of elements, finding boundary nodes, and creating separate models—typically takes experienced engineers three days of manual work. The sheer volume of data makes it error-prone and incredibly tedious. This is exactly what I set out to automate during my internship.

Here's where things get tricky: parsing millions of these structured text cards while preserving their original context. Unlike typical data processing, where you might not care about the original format, structural engineers depend on file organization and comments for understanding complex models. Losing this context isn't just inconvenient—it's a dealbreaker for teams working on certification-critical aircraft.

My first instinct, like any developer facing a new and complex domain, was to find an existing open-source solution. I discovered `pyNastran`, a Python library designed for reading and writing NASTRAN files. It was excellent at parsing hundreds of card types and allowed me to quickly understand the intricacies of the NASTRAN format.

The project seemed to be on a fast track until I hit a critical roadblock: writing the changes back to the files. `pyNastran`'s approach was to flatten the entire model, consolidating dozens of logically-separated files into a single, monolithic object. When it wrote the data back out, the original file structure, engineer comments, and formatting—all priceless human context—were destroyed.

---

While it initially felt like I was back to square one, the time I spent with `pyNastran` ended up informing the structure of my next approach. Having seen its architecture, I now had a much clearer picture of how to design my own card classes and parsing logic.

This led to the creation of the `fem-deck-tool`—my custom library built specifically for parsing and modifying the Finite Element Model representations of aircraft.

At its core, the `fem-deck-tool` is a parser built on one guiding principle: preserve everything. It reads and understands the entire web of NASTRAN run-deck files, but it never loses track of where each card came from, what comments were next to it, or its position within a file. It creates a rich, queryable representation of the aircraft model while maintaining the original file structure and card formatting when writing out modifications.

The `fem-deck-tool` was developed alongside the DMIG (Direct Matrix Input Generation) tool—the automated superelement creation process that would replace those three days of manual work separating the wing from the rest of the plane. 

The DMIG required multiple types of complex operations on the same massive dataset: removing irrelevant load cases, commenting out hundreds of thousands of cards, and adding and moving cards to the top level of the file hierarchy. I realized doing a separate pass through the entire file tree for each operation type would be computationally disastrous.

My solution was to design a **single-pass batch processing system**. First, after parsing the run-deck, I collected, organized, and verified all the requested operations—checking for card existence, linting correct card types, and separating similar card operations into a logical order. Then, the tool traverses the file tree just once, applying all relevant operations as it visits each file. I implemented logical flags that allowed the system to exit files early without needing to scan through all its lines, by using a top-level dictionary to check in constant time if that file had any cards that were required by an operation.

I ran into a big issue with my architecture when I discovered that some cards like `FORCE` and `MOMENT` could exist multiple times—not just in a single file, but scattered anywhere in the run-deck. Their field values, when computed, are the sum of all their instances. Previously, I had only accounted for unique `(card_type, card_id)` combinations, which was insufficient for these cases. To solve this, I initialized a central set for each `list_card` that I needed to alter, during the processing phase. It would track all instances of these cards across every file. As each file was visited, it checks for any `list_cards`, modifies them according to the specified operation, and updates the central tracker. This process continues until all instances of all `list_cards` are handled, ensuring that every occurrence is processed efficiently and correctly, no matter where it appears in the run-deck.

The most complex challenge emerged with the need to generate two different versions of the original model from a single checkpoint. My implementation thus far couldn't handle this because any operation was a destructive change to the in-memory model with no history. The only way to "go back" was to re-parse the entire run-deck, which wasn't viable with larger models.

The solution was to implement an **undo state management system**. Every single modification is recorded as a `change` object and appended to a stack. The `undo()` method then pops the last batch of changes and precisely reverses them, with logic to handle complex scenarios like prioritizing the reversal of `move` operations to ensure file indices are restored correctly before other cards are put back in their original place.

This allowed the DMIG tool to apply multiple sets of changes, write the files, `undo()` back to the checkpoint, and then apply a second set of changes, all without re-parsing or cloning the model's state. Ultimately, I had transformed that three-day manual process into an automated workflow that completes in under 10 seconds while preserving every bit of engineering context.

What started as a deeply specific automation task evolved into building a definitive library that any future developer or structural engineer could use to interface with any finite element model. The impact was immediate outside the DMIG tool—I retrofitted a previous Numerical Buckling tool to be faster and more accurate, and developed a prototype of a Coordinate Symmetry tool for my supervisor in only 30 minutes. Without the library, just implementing the parsing and modification logic for these tools would have taken days each.

In many ways, what I had built acted as a domain-specific language for altering the finite element representations of aircraft, which act as the basis of structural analysis. It allowed engineers to express and perform structural modifications easier, through interfacing with the powerful and comprehensive standard library functions.
